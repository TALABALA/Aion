"""
AION Autonomous Goal System Types

Core dataclasses for goal representation and management.
These types form the foundation for autonomous goal pursuit.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import Any, Callable, Optional, Union
import uuid


class GoalStatus(str, Enum):
    """Status of a goal in its lifecycle."""
    PROPOSED = "proposed"        # Suggested but not approved
    PENDING = "pending"          # Approved, waiting to start
    ACTIVE = "active"            # Currently being pursued
    PAUSED = "paused"            # Temporarily suspended
    BLOCKED = "blocked"          # Waiting on dependency or resource
    COMPLETED = "completed"      # Successfully achieved
    FAILED = "failed"            # Could not be achieved
    ABANDONED = "abandoned"      # Deliberately stopped
    SUPERSEDED = "superseded"    # Replaced by another goal


class GoalPriority(int, Enum):
    """Priority levels for goals."""
    CRITICAL = 1      # Must be done, highest priority
    HIGH = 2          # Important, do soon
    MEDIUM = 3        # Normal priority
    LOW = 4           # Nice to have
    BACKGROUND = 5    # Do when nothing else


class GoalType(str, Enum):
    """Types of goals based on their nature."""
    ACHIEVEMENT = "achievement"    # One-time accomplishment
    MAINTENANCE = "maintenance"    # Ongoing state to maintain
    IMPROVEMENT = "improvement"    # Continuous improvement
    LEARNING = "learning"          # Acquire knowledge/skill
    CREATION = "creation"          # Build or create something
    EXPLORATION = "exploration"    # Investigate or research
    OPTIMIZATION = "optimization"  # Make something better


class GoalSource(str, Enum):
    """Source of a goal - how it was created."""
    USER = "user"                  # Explicitly requested by user
    SYSTEM = "system"              # Generated by AION's reasoning
    DERIVED = "derived"            # Derived from another goal
    SCHEDULED = "scheduled"        # From scheduled task
    TRIGGERED = "triggered"        # From event trigger
    VALUE_ALIGNED = "value_aligned"  # From value system


@dataclass
class GoalConstraint:
    """
    A constraint on goal execution.

    Constraints can be temporal, resource-based, dependency-based,
    or require human approval.
    """
    type: str  # "time", "resource", "dependency", "approval", "safety"
    description: str

    # For time constraints
    deadline: Optional[datetime] = None
    earliest_start: Optional[datetime] = None

    # For resource constraints
    max_tokens: Optional[int] = None
    max_cost_dollars: Optional[float] = None
    max_duration_hours: Optional[float] = None
    max_tool_calls: Optional[int] = None

    # For dependency constraints
    depends_on_goals: list[str] = field(default_factory=list)
    depends_on_conditions: list[str] = field(default_factory=list)

    # For approval constraints
    requires_approval: bool = False
    approval_level: str = "user"  # "user", "admin", "auto"
    approved_by: Optional[str] = None
    approved_at: Optional[datetime] = None

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary representation."""
        return {
            "type": self.type,
            "description": self.description,
            "deadline": self.deadline.isoformat() if self.deadline else None,
            "earliest_start": self.earliest_start.isoformat() if self.earliest_start else None,
            "max_tokens": self.max_tokens,
            "max_cost_dollars": self.max_cost_dollars,
            "max_duration_hours": self.max_duration_hours,
            "requires_approval": self.requires_approval,
            "approval_level": self.approval_level,
            "depends_on_goals": self.depends_on_goals,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "GoalConstraint":
        """Create from dictionary."""
        deadline = None
        if data.get("deadline"):
            deadline = datetime.fromisoformat(data["deadline"])

        earliest_start = None
        if data.get("earliest_start"):
            earliest_start = datetime.fromisoformat(data["earliest_start"])

        return cls(
            type=data.get("type", ""),
            description=data.get("description", ""),
            deadline=deadline,
            earliest_start=earliest_start,
            max_tokens=data.get("max_tokens"),
            max_cost_dollars=data.get("max_cost_dollars"),
            max_duration_hours=data.get("max_duration_hours"),
            requires_approval=data.get("requires_approval", False),
            approval_level=data.get("approval_level", "user"),
            depends_on_goals=data.get("depends_on_goals", []),
            depends_on_conditions=data.get("depends_on_conditions", []),
        )


@dataclass
class GoalMetrics:
    """Metrics for tracking goal progress and resource usage."""
    progress_percent: float = 0.0

    # Effort tracking
    tokens_used: int = 0
    tool_calls: int = 0
    time_spent_seconds: float = 0.0
    api_calls: int = 0

    # Subgoal tracking
    subgoals_total: int = 0
    subgoals_completed: int = 0
    subgoals_failed: int = 0

    # Attempt tracking
    attempts: int = 0
    failures: int = 0
    retries: int = 0

    # Quality metrics
    confidence_score: float = 0.0
    quality_score: float = 0.0
    estimated_completion: Optional[datetime] = None

    # Timestamps
    last_progress_at: Optional[datetime] = None

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary representation."""
        return {
            "progress_percent": self.progress_percent,
            "tokens_used": self.tokens_used,
            "tool_calls": self.tool_calls,
            "time_spent_seconds": self.time_spent_seconds,
            "api_calls": self.api_calls,
            "subgoals_completed": f"{self.subgoals_completed}/{self.subgoals_total}",
            "attempts": self.attempts,
            "failures": self.failures,
            "confidence_score": self.confidence_score,
            "quality_score": self.quality_score,
            "estimated_completion": self.estimated_completion.isoformat() if self.estimated_completion else None,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "GoalMetrics":
        """Create from dictionary."""
        estimated_completion = None
        if data.get("estimated_completion"):
            estimated_completion = datetime.fromisoformat(data["estimated_completion"])

        last_progress_at = None
        if data.get("last_progress_at"):
            last_progress_at = datetime.fromisoformat(data["last_progress_at"])

        return cls(
            progress_percent=data.get("progress_percent", 0.0),
            tokens_used=data.get("tokens_used", 0),
            tool_calls=data.get("tool_calls", 0),
            time_spent_seconds=data.get("time_spent_seconds", 0.0),
            api_calls=data.get("api_calls", 0),
            subgoals_total=data.get("subgoals_total", 0),
            subgoals_completed=data.get("subgoals_completed", 0),
            subgoals_failed=data.get("subgoals_failed", 0),
            attempts=data.get("attempts", 0),
            failures=data.get("failures", 0),
            retries=data.get("retries", 0),
            confidence_score=data.get("confidence_score", 0.0),
            quality_score=data.get("quality_score", 0.0),
            estimated_completion=estimated_completion,
            last_progress_at=last_progress_at,
        )

    def update_progress(self, new_progress: float) -> None:
        """Update progress percentage with timestamp."""
        self.progress_percent = min(100.0, max(0.0, new_progress))
        self.last_progress_at = datetime.now()


@dataclass
class Goal:
    """
    A goal that AION is pursuing.

    Goals are the fundamental unit of autonomous behavior. They represent
    specific objectives that AION can work toward independently.
    """
    id: str = field(default_factory=lambda: str(uuid.uuid4()))

    # Core definition
    title: str = ""
    description: str = ""
    success_criteria: list[str] = field(default_factory=list)

    # Classification
    goal_type: GoalType = GoalType.ACHIEVEMENT
    source: GoalSource = GoalSource.SYSTEM
    priority: GoalPriority = GoalPriority.MEDIUM

    # Status
    status: GoalStatus = GoalStatus.PROPOSED
    status_reason: Optional[str] = None

    # Hierarchy
    parent_goal_id: Optional[str] = None
    subgoal_ids: list[str] = field(default_factory=list)

    # Constraints
    constraints: list[GoalConstraint] = field(default_factory=list)

    # Execution
    plan_id: Optional[str] = None  # Link to execution plan
    agent_id: Optional[str] = None  # Link to executing agent

    # Progress
    metrics: GoalMetrics = field(default_factory=GoalMetrics)

    # Context
    context: dict[str, Any] = field(default_factory=dict)
    tags: list[str] = field(default_factory=list)

    # Timestamps
    created_at: datetime = field(default_factory=datetime.now)
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    deadline: Optional[datetime] = None

    # Results
    outcome: Optional[str] = None
    artifacts: list[str] = field(default_factory=list)  # IDs of created artifacts
    learnings: list[str] = field(default_factory=list)  # Lessons learned

    # Value tracking
    expected_value: float = 0.5  # Expected value if achieved (0-1)
    actual_value: Optional[float] = None  # Actual value after completion

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary representation."""
        return {
            "id": self.id,
            "title": self.title,
            "description": self.description,
            "success_criteria": self.success_criteria,
            "goal_type": self.goal_type.value,
            "source": self.source.value,
            "priority": self.priority.name,
            "status": self.status.value,
            "status_reason": self.status_reason,
            "parent_goal_id": self.parent_goal_id,
            "subgoal_ids": self.subgoal_ids,
            "constraints": [c.to_dict() for c in self.constraints],
            "plan_id": self.plan_id,
            "agent_id": self.agent_id,
            "metrics": self.metrics.to_dict(),
            "context": self.context,
            "tags": self.tags,
            "created_at": self.created_at.isoformat(),
            "started_at": self.started_at.isoformat() if self.started_at else None,
            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
            "deadline": self.deadline.isoformat() if self.deadline else None,
            "outcome": self.outcome,
            "artifacts": self.artifacts,
            "learnings": self.learnings,
            "expected_value": self.expected_value,
            "actual_value": self.actual_value,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "Goal":
        """Create from dictionary."""
        created_at = datetime.now()
        if data.get("created_at"):
            created_at = datetime.fromisoformat(data["created_at"])

        started_at = None
        if data.get("started_at"):
            started_at = datetime.fromisoformat(data["started_at"])

        completed_at = None
        if data.get("completed_at"):
            completed_at = datetime.fromisoformat(data["completed_at"])

        deadline = None
        if data.get("deadline"):
            deadline = datetime.fromisoformat(data["deadline"])

        constraints = [
            GoalConstraint.from_dict(c) for c in data.get("constraints", [])
        ]

        metrics = GoalMetrics()
        if data.get("metrics"):
            metrics = GoalMetrics.from_dict(data["metrics"])

        return cls(
            id=data.get("id", str(uuid.uuid4())),
            title=data.get("title", ""),
            description=data.get("description", ""),
            success_criteria=data.get("success_criteria", []),
            goal_type=GoalType(data.get("goal_type", "achievement")),
            source=GoalSource(data.get("source", "system")),
            priority=GoalPriority[data.get("priority", "MEDIUM")],
            status=GoalStatus(data.get("status", "proposed")),
            status_reason=data.get("status_reason"),
            parent_goal_id=data.get("parent_goal_id"),
            subgoal_ids=data.get("subgoal_ids", []),
            constraints=constraints,
            plan_id=data.get("plan_id"),
            agent_id=data.get("agent_id"),
            metrics=metrics,
            context=data.get("context", {}),
            tags=data.get("tags", []),
            created_at=created_at,
            started_at=started_at,
            completed_at=completed_at,
            deadline=deadline,
            outcome=data.get("outcome"),
            artifacts=data.get("artifacts", []),
            learnings=data.get("learnings", []),
            expected_value=data.get("expected_value", 0.5),
            actual_value=data.get("actual_value"),
        )

    def is_active(self) -> bool:
        """Check if goal is actively being pursued."""
        return self.status in (GoalStatus.ACTIVE, GoalStatus.PENDING)

    def is_terminal(self) -> bool:
        """Check if goal is in a terminal state."""
        return self.status in (
            GoalStatus.COMPLETED,
            GoalStatus.FAILED,
            GoalStatus.ABANDONED,
            GoalStatus.SUPERSEDED,
        )

    def is_successful(self) -> bool:
        """Check if goal was successfully completed."""
        return self.status == GoalStatus.COMPLETED

    def can_start(self) -> bool:
        """Check if goal can be started."""
        if self.status != GoalStatus.PENDING:
            return False

        # Check time constraints
        now = datetime.now()
        for constraint in self.constraints:
            if constraint.earliest_start and now < constraint.earliest_start:
                return False
            if constraint.requires_approval and not constraint.approved_at:
                return False

        return True

    def get_age(self) -> timedelta:
        """Get the age of this goal."""
        return datetime.now() - self.created_at

    def get_duration(self) -> Optional[timedelta]:
        """Get the execution duration if started."""
        if not self.started_at:
            return None
        end_time = self.completed_at or datetime.now()
        return end_time - self.started_at

    def has_deadline(self) -> bool:
        """Check if goal has a deadline."""
        return self.deadline is not None

    def is_overdue(self) -> bool:
        """Check if goal is past its deadline."""
        if not self.deadline:
            return False
        return datetime.now() > self.deadline and not self.is_terminal()

    def time_until_deadline(self) -> Optional[timedelta]:
        """Get time remaining until deadline."""
        if not self.deadline:
            return None
        return self.deadline - datetime.now()


@dataclass
class Objective:
    """
    A high-level objective that encompasses multiple goals.

    Objectives represent broader aspirations that guide goal generation.
    They provide strategic direction for autonomous behavior.
    """
    id: str = field(default_factory=lambda: str(uuid.uuid4()))

    # Definition
    name: str = ""
    description: str = ""
    rationale: str = ""  # Why this objective matters

    # Alignment
    values_aligned: list[str] = field(default_factory=list)  # Which values this serves

    # Goals
    goal_ids: list[str] = field(default_factory=list)

    # Status
    active: bool = True
    progress_percent: float = 0.0

    # Priority
    priority: int = 1  # Lower = more important

    # Timestamps
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)

    # Metadata
    metadata: dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary representation."""
        return {
            "id": self.id,
            "name": self.name,
            "description": self.description,
            "rationale": self.rationale,
            "values_aligned": self.values_aligned,
            "goal_ids": self.goal_ids,
            "active": self.active,
            "progress_percent": self.progress_percent,
            "priority": self.priority,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
            "metadata": self.metadata,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "Objective":
        """Create from dictionary."""
        created_at = datetime.now()
        if data.get("created_at"):
            created_at = datetime.fromisoformat(data["created_at"])

        updated_at = datetime.now()
        if data.get("updated_at"):
            updated_at = datetime.fromisoformat(data["updated_at"])

        return cls(
            id=data.get("id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            rationale=data.get("rationale", ""),
            values_aligned=data.get("values_aligned", []),
            goal_ids=data.get("goal_ids", []),
            active=data.get("active", True),
            progress_percent=data.get("progress_percent", 0.0),
            priority=data.get("priority", 1),
            created_at=created_at,
            updated_at=updated_at,
            metadata=data.get("metadata", {}),
        )

    def update_progress(self, completed_goals: int, total_goals: int) -> None:
        """Update progress based on completed goals."""
        if total_goals > 0:
            self.progress_percent = (completed_goals / total_goals) * 100
        self.updated_at = datetime.now()


@dataclass
class GoalProposal:
    """A proposed goal awaiting evaluation."""
    goal: Goal
    reasoning: str  # Why this goal was proposed
    expected_value: float  # Expected value if achieved (0-1)
    expected_effort: float  # Expected effort (0-1)
    confidence: float  # Confidence in estimates (0-1)
    alternatives: list[str] = field(default_factory=list)  # Alternative approaches

    # Evaluation results
    evaluation_score: Optional[float] = None
    evaluation_reasoning: Optional[str] = None

    # Decision
    approved: Optional[bool] = None
    approved_at: Optional[datetime] = None
    rejected_reason: Optional[str] = None

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary representation."""
        return {
            "goal": self.goal.to_dict(),
            "reasoning": self.reasoning,
            "expected_value": self.expected_value,
            "expected_effort": self.expected_effort,
            "confidence": self.confidence,
            "alternatives": self.alternatives,
            "evaluation_score": self.evaluation_score,
            "evaluation_reasoning": self.evaluation_reasoning,
            "approved": self.approved,
            "approved_at": self.approved_at.isoformat() if self.approved_at else None,
            "rejected_reason": self.rejected_reason,
        }


@dataclass
class GoalEvent:
    """An event in a goal's lifecycle."""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    goal_id: str = ""
    event_type: str = ""  # "created", "started", "progress", "blocked", "completed", etc.
    description: str = ""
    data: dict[str, Any] = field(default_factory=dict)
    timestamp: datetime = field(default_factory=datetime.now)

    # Event source
    source: str = "system"  # "system", "user", "agent"
    source_id: Optional[str] = None

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary representation."""
        return {
            "id": self.id,
            "goal_id": self.goal_id,
            "event_type": self.event_type,
            "description": self.description,
            "data": self.data,
            "timestamp": self.timestamp.isoformat(),
            "source": self.source,
            "source_id": self.source_id,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "GoalEvent":
        """Create from dictionary."""
        timestamp = datetime.now()
        if data.get("timestamp"):
            timestamp = datetime.fromisoformat(data["timestamp"])

        return cls(
            id=data.get("id", str(uuid.uuid4())),
            goal_id=data.get("goal_id", ""),
            event_type=data.get("event_type", ""),
            description=data.get("description", ""),
            data=data.get("data", {}),
            timestamp=timestamp,
            source=data.get("source", "system"),
            source_id=data.get("source_id"),
        )


@dataclass
class ValuePrinciple:
    """
    A core value that guides goal generation and prioritization.

    Values define what AION cares about and how it makes decisions.
    """
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str = ""
    description: str = ""
    priority: int = 1  # Lower = more important

    # How this value affects decisions
    goal_generation_prompt: str = ""  # How to consider this value when generating goals
    prioritization_weight: float = 1.0  # Weight in priority calculations

    # Constraints this value imposes
    constraints: list[str] = field(default_factory=list)

    # Examples
    positive_examples: list[str] = field(default_factory=list)
    negative_examples: list[str] = field(default_factory=list)

    # Status
    active: bool = True

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary representation."""
        return {
            "id": self.id,
            "name": self.name,
            "description": self.description,
            "priority": self.priority,
            "goal_generation_prompt": self.goal_generation_prompt,
            "prioritization_weight": self.prioritization_weight,
            "constraints": self.constraints,
            "positive_examples": self.positive_examples,
            "negative_examples": self.negative_examples,
            "active": self.active,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "ValuePrinciple":
        """Create from dictionary."""
        return cls(
            id=data.get("id", str(uuid.uuid4())),
            name=data.get("name", ""),
            description=data.get("description", ""),
            priority=data.get("priority", 1),
            goal_generation_prompt=data.get("goal_generation_prompt", ""),
            prioritization_weight=data.get("prioritization_weight", 1.0),
            constraints=data.get("constraints", []),
            positive_examples=data.get("positive_examples", []),
            negative_examples=data.get("negative_examples", []),
            active=data.get("active", True),
        )


@dataclass
class GoalProgress:
    """Represents progress update for a goal."""
    goal_id: str
    progress_percent: float
    status: GoalStatus
    message: str = ""
    artifacts_created: list[str] = field(default_factory=list)
    criteria_met: list[str] = field(default_factory=list)
    blockers: list[str] = field(default_factory=list)
    timestamp: datetime = field(default_factory=datetime.now)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary representation."""
        return {
            "goal_id": self.goal_id,
            "progress_percent": self.progress_percent,
            "status": self.status.value,
            "message": self.message,
            "artifacts_created": self.artifacts_created,
            "criteria_met": self.criteria_met,
            "blockers": self.blockers,
            "timestamp": self.timestamp.isoformat(),
        }


@dataclass
class ExecutionContext:
    """Context for goal execution."""
    goal: Goal
    plan_id: Optional[str] = None
    agent_id: Optional[str] = None
    start_time: datetime = field(default_factory=datetime.now)
    timeout_seconds: Optional[float] = None
    max_retries: int = 3
    retry_count: int = 0

    # Resource tracking
    tokens_budget: Optional[int] = None
    tokens_used: int = 0
    cost_budget: Optional[float] = None
    cost_used: float = 0.0

    # State
    paused: bool = False
    cancelled: bool = False

    def is_within_budget(self) -> bool:
        """Check if still within resource budget."""
        if self.tokens_budget and self.tokens_used >= self.tokens_budget:
            return False
        if self.cost_budget and self.cost_used >= self.cost_budget:
            return False
        return True

    def is_timed_out(self) -> bool:
        """Check if execution has timed out."""
        if not self.timeout_seconds:
            return False
        elapsed = (datetime.now() - self.start_time).total_seconds()
        return elapsed >= self.timeout_seconds
